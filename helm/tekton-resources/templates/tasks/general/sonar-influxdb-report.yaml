apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: sonar-scanner
  namespace: tekton-tasks
spec:
  description: >
    This Task retrieves data from a SonarQube analysis, assesses the project's security, and reports the results. It ensures that the project meets the minimum security requirements.

    Parameters:

    - name: deployment-name
      description: The name of the deployment.
      type: string
    - name: registry-url
      description: The URL of the Harbor repository.
      type: string
    - name: sonar-url
      description: The route to SonarQube.
      type: string
    - name: project-key-tenant
      description: The tenant for the project.
      type: string
    - name: influxdb-bucket
      description: influxdb bucket
      type: string
    - name: influxdb-url
      description: influxdb url
      type: string
    - name: env
      description: project environment
      type: string
    - name: project-element
      description: project element
      type: string

    Workspaces:

    - name: output
      description: The workspace consisting of a Maven project.

    The Task performs the following steps:
    
    1. Retrieves the SonarQube URL and login credentials from files.
    2. Defines a SonarQube class to interact with the SonarQube API.
    3. Gets the project key by name.
    4. Gets the project status from the SonarQube API.
    5. Retrieves the issues for the project.
    6. Retrieves the lines of code for the project.
    7. Prints the results of the analysis, including blocker, critical, major, and minor issues.
    8. Checks if the project meets the minimum security requirements based on the issues.
    9. Stores the analysis results in InfluxDB for monitoring.
    10. Displays the final status of the analysis.

  workspaces:
    - name: output
      description: The workspace consisting of a Maven project.
  params:
    - name: deployment-name
      description: The name of the deployment.
      type: string
    - name: registry-url
      description: The URL of the Harbor repository.
      type: string
    - name: sonar-url
      description: The route to SonarQube.
      type: string
    - name: project-key-tenant
      description: The tenant for the project.
      type: string
    - name: influxdb-bucket
      description: influxdb bucket
      type: string
    - name: influxdb-url
      description: influxdb url
      type: string
    - name: env
      description: project environment
      type: string
    - name: project-element
      description: project element
      type: string
  steps:
    - name: sonar-scan-influxdb-report
      image: $(params.registry-url)/python-influxdb:latest
      imagePullSecrets:
      - name: quay-pull-secret
      workingDir: $(workspaces.output.path)
      env:
        - name: LOGIN
          valueFrom:
            secretKeyRef:
              name: sonar-credentials
              key: token
        - name: INFLUXDB_TOKEN
          valueFrom:
            secretKeyRef:
              name: influxdb-token
              key: token
      script: |
        #!/usr/bin/env python3

        import requests
        import os
        import influxdb_client
        from influxdb_client import InfluxDBClient, Point
        from influxdb_client.client.write_api import SYNCHRONOUS

        class SonarQube:
            def __init__(self, url_base, token):
                self.auth = (token, '')
                self.URL_BASE = url_base

            def getProjectKeyByName(self, project_name):
                url = self.URL_BASE + '/api/projects/search'
                response = requests.get(url, auth=self.auth, verify=False)
                if response.status_code == 200:
                    for i in response.json('components'):
                        if i['name'] == project_name:
                            return i['key']
                else:
                    exit(0)

            def getCodeDuplication(self, project_key_tenant):
                url = self.URL_BASE + '/api/measures/component'
                params = {'component': project_key_tenant, 'metricKeys': 'duplicated_lines_density'}
                response = requests.get(url, params=params, auth=self.auth, verify=False)
                if response.status_code == 200:
                    duplicity_str = response.json()['component']['measures'][0]['value']
                    duplicity = float(duplicity_str.replace('%', ''))
                    return duplicity
                else:
                    print('Duplicidad fallida')
                    exit(0)

            def getCoverage(self, project_key_tenant):
                url = self.URL_BASE + '/api/measures/component'
                params = {'component': project_key_tenant, 'metricKeys': 'coverage'}
                response = requests.get(url, params=params, auth=self.auth, verify=False)
                if response.status_code == 200:
                    coverage_str = response.json()['component']['measures'][0]['value']
                    coverage = float(coverage_str.replace('%', ''))
                    return coverage
                else:
                    exit(0)

            def getProjectStatus(self, project_key_tenant):
                url = self.URL_BASE + '/api/qualitygates/project_status'
                params = {'projectKey': project_key_tenant}
                response = requests.get(url, params=params, auth=self.auth, verify=False)
                if response.status_code == 200:
                    status = response.json()['projectStatus']['status']
                    return status
                else:
                    exit(0)

            def getIssuesFromProject(self, project_key_tenant):
                url = self.URL_BASE + '/api/issues/search'
                manage = False
                page = 1
                issues = {'TOTAL': 0, 'INFO': 0, 'MINOR': 0, 'MAJOR': 0, 'CRITICAL': 0, 'BLOCKER': 0}
                while not manage:
                    params = {'componentKeys': project_key_tenant, 'p': page}
                    response = requests.get(url, params=params, auth=self.auth, verify=False)
                    if response.status_code == 200:
                        issues['TOTAL'] += len(response.json()['issues'])
                        for i in response.json()['issues']:
                            issues[i['severity']] += 1
                        if issues['TOTAL'] == response.json()['total']:
                            manage = True
                        else:
                            page += 1
                    else:
                        exit(0)
                return issues

            def getLinesCode(self, project_key_tenant):
                url = self.URL_BASE + '/api/measures/component'
                params = {'component': project_key_tenant, 'metricKeys': 'ncloc'}
                response = requests.get(url, params=params, auth=self.auth, verify=False)
                if response.status_code == 200:
                    for i in response.json()['component']['measures']:
                        if i['metric'] == 'ncloc':
                            return i['value']
                else:
                    exit(0)

            def storeDataInInfluxDB(self, project, env, project_element, project_key_tenant, quality_gate_result, influxdb_url, influxdb_token, influxdb_bucket, issues, code_duplication, coverage):
                organization = 'DES'
                client = InfluxDBClient(url=influxdb_url, org=organization, token=influxdb_token)

                if project_element == 'back':
                    framework_tag = 'java'
                elif project_element == 'quarkus':
                    framework_tag = 'quarkus'
                elif project_element == 'front':
                    framework_tag = 'angular'
                else:
                    framework_tag = 'unknown'

                write_api = client.write_api(write_options=SYNCHRONOUS)
                point = (
                    Point('sonarqube_metrics')
                    .tag('project_tag', project)
                    .tag('Environment_tag', env)
                    .tag('Framework_tag', framework_tag)
                    .tag('Tenant_tag', project_key_tenant)
                    .tag('Element_tag', project_element)
                    .field('quality_gate_status', quality_gate_result)
                    .field('blocker', issues['BLOCKER'])
                    .field('critical', issues['CRITICAL'])
                    .field('major', issues['MAJOR'])
                    .field('minor', issues['MINOR'])
                    .field('info', issues['INFO'])
                    .field('total', issues['TOTAL'])
                    .field('code_duplication', code_duplication)
                    .field('coverage', coverage)
                )
                write_api.write(influxdb_bucket, organization, point)

            def printProjectDetails(self, project, env, project_element, quality_gate_result, issues, coverage, duplication, lines_code):
                print('+++++++++++++++++++++++++++++++++++++++++++')
                print('PROJECT INFO:')
                print('+++++++++++++++++++++++++++++++++++++++++++')
                print(f'Project Name: {project}')
                print(f'Environment: {env}')
                print(f'Element: {project_element}')
                print('+++++++++++++++++++++++++++++++++++++++++++')
                print('PROJECT METRICS:')
                print('+++++++++++++++++++++++++++++++++++++++++++')
                print(f'Estado del Quality Gate: {quality_gate_result}')
                print(f'Incidencias Totales: = ' + str(issues['TOTAL']))
                print('Incidencias BLOQUEANTES = ' + str(issues['BLOCKER']))
                print('Incidencias CRITICAS = ' + str(issues['CRITICAL']))
                print('Incidencias ALTAS = ' + str(issues['MAJOR']))
                print('Incidencias BAJAS = ' + str(issues['MINOR']))
                print('Incidencias INFORMATIVAS = ' + str(issues['INFO']))
                print(f'Líneas de código: {lines_code}')
                print(f'Cobertura: {coverage}%')
                print(f'Duplicidad de código: {duplication}%')
                print('+++++++++++++++++++++++++++++++++++++++++++')

        def main():
            URL_BASE = os.environ.get("PARAMS_SONAR_URL", "http://example.com")
            TOKEN = os.environ.get("LOGIN", "default_token")
            project = os.environ.get("PARAMS_DEPLOYMENT_NAME", "default_project")
            env = os.environ.get("PARAMS_ENV", "default_env")
            project_element = os.environ.get("PARAMS_PROJECT_ELEMENT", "back")
            project_key_tenant = os.environ.get("PARAMS_PROJECT_KEY_TENANT", "default_key")
            influxdb_url = os.environ.get("PARAMS_INFLUXDB_URL", "http://influxdb.example.com")
            influxdb_bucket = os.environ.get("PARAMS_INFLUXDB_BUCKET", "default_bucket")
            INFLUXDB_TOKEN = os.environ.get("INFLUXDB_TOKEN", "default_influxdb_token")

            print('Starting the SonarQube analysis script, getting parameters...')
            sonarQube = SonarQube(URL_BASE, TOKEN)

            print('Getting issues...')
            issues = sonarQube.getIssuesFromProject(project_key_tenant)

            print('Getting Quality Gate status...')
            quality_gate = sonarQube.getProjectStatus(project_key_tenant)

            quality_gate_result = 1 if quality_gate == 'OK' else 0

            print('Getting code duplication...')
            duplication = sonarQube.getCodeDuplication(project_key_tenant)

            print('Getting coverage...')
            coverage = sonarQube.getCoverage(project_key_tenant)

            print('Getting lines of code...')
            lines_code = sonarQube.getLinesCode(project_key_tenant)

            sonarQube.printProjectDetails(project, env, project_element, quality_gate_result, issues, coverage, duplication, lines_code)

            print('Storing data into InfluxDB bucket...')
            sonarQube.storeDataInInfluxDB(project, env, project_element, project_key_tenant, quality_gate_result, influxdb_url, INFLUXDB_TOKEN, influxdb_bucket, issues, duplication, coverage)

            print('+++++++++++++++++++++++++++++++++++++++++++')
            print('DATA SUCCESSFULLY STORED')
            print('+++++++++++++++++++++++++++++++++++++++++++')

        main()
